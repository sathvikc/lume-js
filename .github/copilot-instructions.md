# Lume.js Copilot Instructions

## Project Overview
Lume.js is a **minimal reactive state library** using only standard JavaScript and HTML (`data-*` attributes). No build step, no custom syntax, no framework lock-in. Think "Modern Knockout.js for 2025."

**Core philosophy:** Standards-only, progressive enhancement, zero-runtime reactivity.

---

## AI Memory System (.ai/ folder)

**Purpose:** Persistent memory across AI chat sessions. NOT committed to git.

**Files:**
- **`v2-development.md`** - Development tracker (tasks, status, decisions, size metrics)
- **`core-principles.md`** - Immutable rules (size budgets, philosophy, release checklist)
- **`size-history.json`** - Size tracking history (last 50 runs, auto-generated)
- **`size-report.md`** - Current size report (auto-generated by `npm run size`)

**Usage Rules:**
1. **Read `.ai/` files on startup** to understand context
2. **Update `.ai/v2-development.md`** when tasks complete or priorities change
3. **Update `.ai/core-principles.md`** when making architectural decisions
4. **Never commit `.ai/` to git** - it's in `.gitignore`
5. **Organize freely** - add new memory files as needed

**When to add new .ai files:**
- Design specs that span multiple sessions (e.g., `plugin-system-spec.md`)
- Decision logs for complex tradeoffs
- API evolution notes
- Migration guides in progress

---

## Architecture

### Three-Layer Reactive System
1. **`state(obj)`** ([src/core/state.js](../src/core/state.js)) - JavaScript Proxy-based reactive state with:
   - Per-state microtask batching (not global scheduler)
   - `$subscribe(key, fn)` for listening to specific keys
   - Automatic dependency tracking via `globalThis.__LUME_CURRENT_EFFECT__`
   - **Must be plain objects** (not primitives/arrays) due to Proxy limitations

2. **`bindDom(root, store)`** ([src/core/bindDom.js](../src/core/bindDom.js)) - DOM bindings via `data-bind` attributes:
   - Auto-waits for `DOMContentLoaded` unless `{ immediate: true }`
   - Two-way binding for form inputs (input/textarea/select)
   - Uses `$subscribe` internally (receives batched updates)

3. **`effect(fn)`** ([src/core/effect.js](../src/core/effect.js)) - Automatic dependency tracking:
   - Sets `globalThis.__LUME_CURRENT_EFFECT__` during execution
   - State getters check this global to register dependencies
   - Re-tracks dependencies on every run (dynamic tracking)
   - Used internally by `computed()` addon

### Addons (Optional Extensions)
- **`computed(fn)`** ([src/addons/computed.js](../src/addons/computed.js)) - Derived values using `effect()`
- **`repeat(selector, store, arrayKey, opts)`** ([src/addons/repeat.js](../src/addons/repeat.js)) - List rendering with:
  - **‚ö†Ô∏è EXPERIMENTAL in v1.0** - API may change
  - Requires **immutable array updates**: `store.items = [...items]` (not `.push()`)
  - Element reuse by key, focus/scroll preservation (configurable)
- **`watch(store, key, fn)`** ([src/addons/watch.js](../src/addons/watch.js)) - Simple key watcher

## Critical Patterns

### State Updates Must Trigger Reactivity
```javascript
// ‚ùå Won't work - mutates array in-place
store.todos.push(newTodo);

// ‚úÖ Works - creates new array reference
store.todos = [...store.todos, newTodo];
```

### Nested State Requires Explicit Wrapping
```javascript
// Each nested level must be wrapped separately
const store = state({
  user: state({ name: 'Alice' }) // Wrap nested objects
});
```

### Effect Dependency Tracking is Dynamic
```javascript
const store = state({ count: 0, name: 'Alice' });

effect(() => {
  if (store.count > 0) {
    console.log(store.name); // Only tracks 'name' when count > 0
  }
});
```

### DOM Binding Auto-Waits for Document Load
```javascript
// Safe to call before DOM ready (default behavior)
bindDom(document.body, store);

// Force immediate binding (use only when DOM is ready)
bindDom(document.body, store, { immediate: true });
```

## Development Workflow

### Running Tests
```bash
npm test              # Run once with Vitest
npm run test:watch    # Watch mode
npm run coverage      # Generate coverage report
```

- Tests use `jsdom` environment (see [vitest.config.js](../vitest.config.js))
- Path alias: `'src'` maps to `./src` (use `from 'src/core/state.js'` in tests)
- Wait for microtasks in tests: `await Promise.resolve()` after state changes

### No Build Step Needed
```bash
npm run build  # Literally echoes "No build step needed!"
npm run size   # Check bundle size with compression
```

### Examples & Dev Server
```bash
npm run dev          # Vite dev server for examples/
npm run dev:site     # Build docs site (gh-pages)
```

- Examples in [examples/](../examples/) use CDN-style imports: `from 'lume-js'`
- Each example has standalone HTML + `main.js` (see [examples/todo/main.js](../examples/todo/main.js))

## Common Pitfalls

### Don't Subscribe Inside Effects
```javascript
// ‚ùå Creates new subscription on every run (memory leak)
effect(() => {
  store.$subscribe('count', () => { /* ... */ });
});

// ‚úÖ Use effect for side effects, subscribe for external listeners
const cleanup = store.$subscribe('count', (val) => {
  console.log('Count changed:', val);
});
```

### Array Methods Won't Trigger Updates
Lume.js doesn't use deep reactivity for arrays. Replace the entire array reference:
```javascript
// ‚ùå Silent failure
store.items.sort();

// ‚úÖ Trigger update
store.items = [...store.items].sort();
```

### Path Resolution in `bindDom`
```html
<!-- Works: nested paths via dot notation -->
<input data-bind="user.profile.email">
```

Requires `store.user` to be a reactive state object (wrapped with `state()`).

## File Organization
- **Core API:** [src/core/](../src/core/) - state, effect, bindDom, utils
- **Addons:** [src/addons/](../src/addons/) - computed, repeat, watch
- **Types:** [src/index.d.ts](../src/index.d.ts) - TypeScript definitions (hand-written)
- **Tests:** [tests/](../tests/) - Mirror structure of src/ (e.g., `tests/core/state.test.js`)
- **Docs:** [docs/](../docs/) - Markdown docs (api/, guides/, tutorials/)

## Design Decisions
Read [docs/design/design-decisions.md](../docs/design/design-decisions.md) for "why" behind:
- Standards-only approach (data-* attributes)
- Objects-only state (Proxy limitations)
- Per-state batching (not global scheduler)
- No virtual DOM (direct DOM manipulation)

## When Adding Features
1. Preserve zero-build-step philosophy (standard JS/HTML only)
2. Keep core minimal - use addons for non-essential features
3. Maintain comprehensive test coverage (114+ tests)
4. Update TypeScript definitions in parallel
5. Add examples to demonstrate usage patterns

---

## Lume.js 2.0 Development Workflow

### Core Principles for AI-Assisted Development

**Philosophy:** Build incrementally with human-like progression, comprehensive testing, and synchronized documentation.

**Role:** Act as both **architect and programmer** - make autonomous decisions, suggest improvements, and build complete solutions. The human is a reviewer who guides through prompts and performs final testing.

**Decision-Making Authority:**
- ‚úÖ **Implement** minor API improvements without asking (better naming, clearer signatures)
- ‚úÖ **Refactor** code for clarity, performance, or size without approval
- ‚úÖ **Choose** implementation details (data structures, algorithms)
- ‚úÖ **Add** defensive checks and error handling as needed
- ‚úÖ **Optimize** bundle size and performance proactively
- ‚ö†Ô∏è **Suggest** major architectural changes or breaking API changes (wait for approval)
- ‚ö†Ô∏è **Propose** alternatives when roadmap approach has issues (explain tradeoffs)

**Autonomous Actions (Just Do It):**
- Fix bugs discovered during implementation
- Add missing edge case handling
- Improve code organization and readability
- Enhance error messages for better DX
- Add performance optimizations
- Update tests to match implementation changes
- Fix type definitions to match code
- Improve documentation clarity
- Add inline code comments for complex logic

**Require Discussion (Suggest First):**
- Changes to public API signatures
- Breaking changes from 1.x behavior
- New features not in roadmap
- Alternative architecture that differs from plan
- Tradeoffs between bundle size and features
- Changes to core philosophy (standards-only, etc.)

### Git Commit Strategy

Follow **Angular Commit Convention** strictly:

```
<type>(<scope>): <subject>

<body>

<footer>
```

**Types:**
- `feat`: New feature (e.g., `feat(core): add plugin system to state.js`)
- `fix`: Bug fix (e.g., `fix(effect): prevent memory leak on cleanup`)
- `refactor`: Code restructuring (e.g., `refactor(state): extract batching logic`)
- `test`: Add/update tests (e.g., `test(effect): add edge cases for nested tracking`)
- `docs`: Documentation only (e.g., `docs(api): update state.js examples`)
- `chore`: Maintenance (e.g., `chore: update vitest to v3`)
- `perf`: Performance improvement (e.g., `perf(repeat): optimize key lookup`)
- `style`: Code style/formatting (e.g., `style(core): fix indentation`)

**Scope:** Use file/module name (`core`, `effect`, `bindDom`, `repeat`, `types`, `tests`)

**Commit Progression Pattern:**
```bash
# 1. Implement the feature
feat(core): add basic plugin hook system

# 2. Add comprehensive tests (100% coverage)
test(plugin): add unit tests for plugin registration
test(plugin): add edge cases for duplicate plugins
test(plugin): add integration test for effect plugin

# 3. Update types
chore(types): add Plugin interface to index.d.ts

# 4. Add documentation
docs(plugin): document plugin API in design-decisions.md

# 5. Add example
docs(examples): add plugin-system example

# 6. Fix issues found during testing
fix(plugin): handle duplicate plugin registration
```

**Each commit should:**
- ‚úÖ Be atomic (one logical change)
- ‚úÖ Pass all tests (`npm test`)
- ‚úÖ Include related type updates if applicable
- ‚úÖ Reference issue/feature (`Refs #123` or `Part of 2.0 plugin system`)

### Feature Development Workflow

**Build feature first, then ensure quality:**

```javascript
// Step 1: Implement the feature in src/
// Step 2: Write comprehensive tests for it
describe('plugin system', () => {
  it('registers plugins and calls hooks', () => {
    const plugin = {
      name: 'test-plugin',
      onGet: vi.fn((key, value) => value)
    };
    
    const store = state({ count: 0 }, { plugins: [plugin] });
    const val = store.count;
    
    expect(plugin.onGet).toHaveBeenCalledWith('count', 0);
  });
});

// Step 3: Add edge cases and integration tests
// Step 4: Update types, docs, examples
// Step 5: Verify 100% coverage and fix any issues
```

**Test Coverage Requirements:**
- ‚úÖ **100% line coverage** - Every line must be executed
- ‚úÖ **100% branch coverage** - Every if/else path tested
- ‚úÖ **Edge cases documented** - Tests explain why edge case exists
- ‚úÖ **Common pitfalls** - Tests prevent mistakes developers make

**Test Organization Pattern:**
```javascript
describe('feature', () => {
  // Happy path tests
  describe('basic functionality', () => {
    it('works in simple case', () => { /* ... */ });
  });
  
  // Edge cases with explanations
  describe('edge cases', () => {
    it('handles empty input (prevent undefined access)', () => {
      // Rationale: Users often forget to check for empty state
      const store = state({});
      expect(() => store.items).not.toThrow();
    });
    
    it('prevents infinite recursion (common pitfall)', () => {
      // Rationale: Easy to create loops with effects
      const store = state({ count: 0 });
      effect(() => {
        store.count++; // Would cause infinite loop
      });
      // Should stabilize, not crash
    });
  });
  
  // Integration tests
  describe('integration', () => {
    it('works with other features', () => { /* ... */ });
  });
});
```

**Run tests before every commit:**
```bash
npm test    after implementation:**
```bash
npm test              # Unit tests (run after writing tests)
npm run coverage      # Verify 100% coverage
npm run test:watch    # During test
### Synchronization Requirements

**Every feature change must update all 4 layers:**

```mermaid
Implementation ‚Üí Tests ‚Üí Types ‚Üí Docs/Examples
     ‚Üì            ‚Üì        ‚Üì         ‚Üì
  state.js ‚Üí state.test.js ‚Üí index.d.ts ‚Üí api/state.md + examples/
```

**Checklist for each feature (deliver complete solution):**
- [ ] ‚úÖ Implementation in `src/` (with inline comments for complex parts)
- [ ] ‚úÖ Tests in `tests/` (100% coverage, edge cases, common pitfalls)
- [ ] ‚úÖ TypeScript types in `*.d.ts` (with JSDoc examples)
- [ ] ‚úÖ API docs in `docs/api/` (with code examples)
- [ ] ‚úÖ Example code in `examples/` (demonstrating real usage)
- [ ] ‚úÖ Design rationale in `docs/design/design-decisions.md` (if architectural)
- [ ] ‚úÖ Self-review: Does this meet quality standards?

**Example workflow for plugin system:**
```bash
# Commit 1: Tests
test(plugin): add plugin registration tests
- tests/coreImplementation
feat(core): add plugin system to state.js
- src/core/state.js (add plugin support)

# Commit 2: Comprehensive tests
test(plugin): add plugin registration tests
- tests/core/state.test.js (new describe block)
- Cover happy path, edge cases, integration

# Commit 3: Types
chore(types): add Plugin interface
- src/index.d.ts (new Plugin type)

# Commit 4: Documentationsign-decisions.md (new section)
- docs/api/core/plugins.md (new file)

# Commit 5: Example
docs(examples): add plugin-system example
- examples/plugin-demo/ (new folder)
```

### Design Decisions Documentation

**Update `docs/design/design-decisions.md` when:**
- Adding new architectural patterns
- Making breaking changes
- Choosing between alternatives
- Introducing non-obvious APIs

**Format for new decisions:**
```markdown
### Why [Feature Name]?

**Decision:** [What was decided]

**Reasoning:**
- [Bullet point rationale]
- [Technical constraints]
- [User benefit]

**Alternatives considered:**
- ‚ùå [Option A] ‚Üí [Why rejected]
- ‚ùå [Option B] ‚Üí [Why rejected]

**Tradeoff:** [What we gained vs what we lost]

**Example:**
\`\`\`javascript
// Show the pattern
\`\`\`
```

### Improvement and Decision-Making Process

**Continuous evaluation during implementation:**
1. ‚úÖ Is there a better API design? ‚Üí If minor, just do it. If major, suggest.
2. ‚úÖ Can we reduce complexity? ‚Üí Simplify immediately.
3. ‚úÖ Are there edge cases we haven't considered? ‚Üí Add handling automatically.
4. ‚úÖ Does this align with "standards-only" philosophy? ‚Üí Must align, course-correct if needed.
5. ‚úÖ Can this be done with fewer bytes? ‚Üí Optimize proactively.

**When to suggest alternatives (major changes only):**
```markdown
## ü§î Architectural Decision: [Feature]

**Roadmap approach:** [Brief description]

**Issue identified:** [What's wrong or could be better]

**Proposed alternative:**
\`\`\`javascript
// Show the better implementation
\`\`\`

**Tradeoffs:**
- ‚úÖ **Gains:** [Size reduction, better DX, simpler code, etc.]
- ‚ö†Ô∏è **Costs:** [API changes, migration effort, etc.]
- üìä **Impact:** [Bundle size delta, breaking changes, etc.]

**Recommendation:** [Proceed with alternative / Stick with roadmap / Needs discussion]
```

**Examples of autonomous improvements (just do):**
- Rename `createPlugin` ‚Üí `plugin` (simpler, consistent)
- Extract repeated logic into helper functions
- Add JSDoc comments for better IntelliSense
- Improve error messages: `"Invalid plugin"` ‚Üí `"plugin.name is required (got undefined)"`
- Optimize loops: `Array.from(set).forEach()` ‚Üí `for (const item of set)`
- Add defensive checks: `if (!obj || typeof obj !== 'object') throw new Error(...)`

**Examples requiring suggestion (architectural):**
- Change plugin API from objects to classes
- Add global state registry (violates minimal philosophy)
- Replace Proxy with Object.defineProperty (major rewrite)
- Add automatic deep reactivity (violates explicit philosophy)

### 2.0 Specific Guidelines

**Plugin System (Phase 1):**
- Each plugin hook needs 5+ tests
- Document hook execution order in code comments
- Include timing diagrams in docs
- Prove tree-shaking with size tests

**Effect as Addon (Phase 2):**
- Verify backward compatibility with 1.x code
- Test that unused effect code is tree-shaken
- Add deprecation warnings for internal API access
- Create migration examples

**Debug System (Phase 3):**
- Must be 0 bytes when not imported
- Test in Node.js and browser environments
- Include devtools integration example
- Document performance impact

**Size Verification:**
```bash
# After each feature
npm run size

# Should output:
# core (state.js): 1.1 KB ‚úì
# + effect: 1.4 KB ‚úì
# + bindDom: 1.9 KB ‚úì Under 2KB budget
```

### Common Pitfalls to Test

Based on past issues, always test:
- Memory leaks from uncleaned subscriptions
- Infinite recursion in effects
- Race conditions in microtask batching
- Effect tracking across multiple states
- Array mutation not triggering updates
- Nested state without explicit wrapping
- DOM queries before DOMContentLoaded
- Empty/null/undefined edge cases

### Architect-Programmer Mindset

**Think like an architect, build like a senior engineer:**

1. **Understand the goal** - Read roadmap, understand "why" not just "what"
2. **Design the solution** - Consider alternatives, choose the best approach
3. **Implement completely** - Code + tests + types + docs + examples in one shot
4. **Self-review** - Does it meet quality standards? Run all checks.
5. **Present** - Show completed work with context and reasoning
6. **Iterate** - Respond to human feedback, improve based on testing

**For every feature, deliver:**
1. ‚úÖ Complete implementation (`feat(scope): description`)
2. ‚úÖ Comprehensive tests (`test(scope): cover all cases`)
3. ‚úÖ Updated types (`chore(types): add interfaces`)
4. ‚úÖ Documentation (`docs(design): explain rationale` if architectural)
5. ‚úÖ Working example (`docs(examples): demonstrate usage`)
6. ‚úÖ Any fixes needed (`fix(scope): handle edge cases`)

**Communication style:**
- üöÄ **Starting:** "Building [feature]. Considering [alternative approaches]. Proceeding with [chosen approach] because [reason]."
- ‚úÖ **Completed:** "Implemented [feature] with [details]. Tests: 100% coverage. Size: +XXX bytes. Ready for review."
- ü§î **Need input:** "Found issue with [roadmap approach]. Suggesting [alternative] - see details. Should I proceed?"
- üîß **Iterating:** "Addressing feedback: [changes]. Re-tested, ready for next review."

### Code Review Self-Checklist

**Perform self-review before presenting to human:**
- [ ] All tests pass (`npm test`)
- [ ] 100% coverage (`npm run coverage`)
- [ ] Types compile (`npx tsc --noEmit`)
- [ ] Size budget met (`npm run size`)
- [ ] API is intuitive (would I understand this without reading docs?)
- [ ] Error messages are helpful (not just "Invalid input")
- [ ] Code is readable (clear variable names, logical flow)
- [ ] Edge cases handled (empty arrays, null, undefined, etc.)
- [ ] Memory leaks prevented (cleanup functions work)
- [ ] Performance optimized (no unnecessary loops/allocations)
- [ ] Docs updated (API + design decisions if needed)
- [ ] Example demonstrates real usage (not toy example)
- [ ] Commits tell a story (logical progression)
- [ ] No console.log/debugger left
- [ ] TypeScript types match implementation

**Quality Gates (Must Pass):**
```bash
npm test           # ‚úÖ All tests pass
npm run coverage   # ‚úÖ 100% coverage
npm run size       # ‚úÖ Under budget (<2KB full bundle)
npx tsc --noEmit   # ‚úÖ No type errors
```it`)
- [ ] Size budget met (`npm run size`)
- [ ] Docs updated (API + design decisions)
- [ ] Example added/updated
- [ ] Commits follow Angular convention
- [ ] No console.log/debugger left
- [ ] Edge cases documented in tests

### Persistent Memory System (Cross-Chat Context)

**Problem:** Decisions and discussions get lost between chat sessions.

**Solution:** Maintain structured memory files in `.ai/` folder that persist across chats.

**Directory Structure:**
```
.ai/
  decisions.md         # Architectural decisions made
  deferred.md          # Features/ideas to revisit later
  known-issues.md      # Bugs and limitations to address
  chat-context.md      # Important context from recent discussions
  implementation-notes.md  # Technical notes and gotchas
```

**When to Update Memory Files (Automatic):**

**1. After architectural discussions:**
```bash
# AI should automatically update .ai/decisions.md
git add .ai/decisions.md
git commit -m "docs(ai): record decision on plugin hook ordering"
```

**2. When deferring features:**
```bash
# AI updates .ai/deferred.md
git add .ai/deferred.md
git commit -m "docs(ai): defer array reactivity helper to 2.1"
```

**3. When discovering issues:**
```bash
# AI updates .ai/known-issues.md
git add .ai/known-issues.md
git commit -m "docs(ai): document edge case in effect cleanup"
```

**4. End of each chat session:**
```bash
# AI updates .ai/chat-context.md with session summary
git add .ai/chat-context.md
git commit -m "docs(ai): update context from plugin system discussion"
```

**Memory File Templates:**

**`.ai/decisions.md`:**
```markdown
# Architectural Decisions Log

## [YYYY-MM-DD] Decision: [Title]

**Context:** What prompted this decision?

**Decision:** What was decided?

**Rationale:**
- Why this approach?
- What alternatives were considered?

**Impact:**
- Bundle size: [¬±X bytes]
- API changes: [Yes/No]
- Breaking: [Yes/No]

**Status:** [Implemented | Approved | Under Review]

---
```

**`.ai/deferred.md`:**
```markdown
# Deferred Items (Revisit Later)

## High Priority

### [Feature Name]
- **Why deferred:** [Reason]
- **Revisit in:** [Version or milestone]
- **Dependencies:** [What needs to happen first]
- **Notes:** [Additional context]

## Low Priority

### [Feature Name]
- **Why deferred:** [Reason]
- **Revisit in:** [Version or milestone]

---
```

**`.ai/known-issues.md`:**
```markdown
# Known Issues & Limitations

## Critical
- None currently

## Medium Priority

### [Issue Title]
- **Affects:** [What functionality]
- **Workaround:** [If any]
- **Fix planned:** [Version]
- **Root cause:** [Technical explanation]

## Low Priority / Won't Fix

### [Issue Title]
- **Why not fixing:** [Philosophy or tradeoff]

---
```

**`.ai/chat-context.md`:**
```markdown
# Recent Chat Context

**Last updated:** [YYYY-MM-DD]

## Current Focus
- Working on: [Feature/Phase]
- Blockers: [Any blockers]
- Next steps: [What's next]

## Recent Discussions

### [YYYY-MM-DD] - [Topic]
- **Discussed:** [Summary]
- **Decided:** [Outcome]
- **Action items:** [What to do]

## Important Reminders
- [Key things to remember]
- [Patterns established]
- [Conventions agreed upon]

---
```

**`.ai/implementation-notes.md`:**
```markdown
# Implementation Notes & Gotchas

## Plugin System

### Hook Execution Order
- onGet runs before value is returned
- onSet runs before subscribers notified
- Exceptions in hooks are caught and logged

### Common Pitfalls
- Don't register plugins inside effects (memory leak)
- Plugin names must be unique (throws error)

## Effect System

### Dependency Tracking
- Uses globalThis.__LUME_CURRENT_EFFECT__
- Re-tracks on every execution (dynamic)
- Infinite recursion protection via isRunning flag

---
```

**AI Agent Responsibilities:**

1. **Read on startup:** Check `.ai/*.md` files for context before starting work
2. **Update during discussion:** When decisions are made, immediately update relevant file
3. **Commit separately:** Memory file updates get their own commits with `docs(ai):` prefix
4. **Keep concise:** Only essential information, link to full docs when needed
5. **Prune old content:** Archive or remove outdated information monthly

**Example Workflow:**

```bash
# Human: "Let's defer the array helper to 2.1, it's too complex for now"

# AI Actions:
# 1. Update .ai/deferred.md
# 2. Commit the change
git add .ai/deferred.md
git commit -m "docs(ai): defer array reactivity helper to 2.1"

# 3. Acknowledge to human
"Recorded in .ai/deferred.md. Will reference this in future chats."
```

**Benefits:**
- ‚úÖ Context persists across chat sessions
- ‚úÖ No need to re-explain decisions
- ‚úÖ Other AI agents can pick up where you left off
- ‚úÖ Human reviewers see the reasoning
- ‚úÖ Git history tracks decision evolution

**Human Override:** You can manually edit these files anytime. AI will sync with latest content.

### Example of a Complete Feature Implementation

See [LUME_2.0_FINAL_ROADMAP.md](../LUME_2.0_FINAL_ROADMAP.md) for the full roadmap context.
